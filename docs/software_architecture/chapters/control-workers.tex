\section{Controlling workers}

One of the things the player can do is order workers to do a specific task.
This is done by selecting one or more workers followed by right clicking
somewhere. For example, the player can right click on the ground, which will
cause the selected workers to move there. The player can also order workers
to gather resources such as wood.

Since the player can select any kind of worker and order it to do many
different things, a design pattern was needed to ensure that the code
remained readable and extensible. The strategy pattern was chosen because of
the fact that it is very extensible.

A class diagram of relevant classes can be found in
\cref{fig:orderstrategies}. The basic idea is that there is one singleton
class named MoveOrder with an order\_move method. This method can be used
throughout the game to order one or more entities to do something at a
certain vector. Based on what the player right clicked on, an OrderStrategy
is selected. This OrderStrategy takes care of the right click event, for
example, by ordering the selected entities to go to a certain location.

Down below, in \cref{lst:groundorderstrategy}, you can find the implementation 
of the strategy that handles the event where a user orders one or more entities
to move to a certain position.
\\
\begin{lstlisting}[caption={GroundOrderStrategy implementation.},
label={lst:groundorderstrategy}]
bool GroundOrderStrategy::applies(std::vector<MovingEntity *> *units, vec2 &targetVector, BaseEntity *target) {
    // when target is nullptr then the user clicked on the ground
    return target == nullptr;
}

void GroundOrderStrategy::execute(std::vector<MovingEntity *> *units, vec2 &targetVector, BaseEntity *target) {
    Graph* graph = GraphManager::get_instance()->graph;
    int goal = graph->get_node_with_position(targetVector);
    goal = graph->find_closest_edge(graph->nodes[goal])->get_index();
    for(int i = 0; i < units->size(); i++){
        MovingEntity* selectedUnit = units->at(i);

        if (selectedUnit->job_type != JobType::ENEMY) {
            int start = graph->get_node_with_position(selectedUnit->get_position());
            std::vector<vec2 *> path = graph->a_star_path(graph->nodes[start], graph->nodes[goal]);

            selectedUnit->get_brain()->remove_all_subgoals();
            selectedUnit->path = path;
            selectedUnit->get_brain()->set_goal_follow_path();
        }
    }
}
\end{lstlisting}
